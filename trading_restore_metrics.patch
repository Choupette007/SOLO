*** Begin Patch
*** Update File: solana_trading_bot_bundle/trading_bot/trading.py
@@
 METRICS = None
 _make_store = None
 try:
@@
     METRICS = None
 
 # Export alias for external wiring/tests
 make_metrics_store = _make_store if _make_store is not None else None
+
+# -------------------------------------------------------------------------
+# Optional runtime MetricsStore wrapper and pattern/bollinger helpers
+# Defensive: best-effort imports and lazy init so core logic keeps working
+# -------------------------------------------------------------------------
+_metrics_store = None  # lazy-initialized MetricsStore wrapper instance
+
+def _metrics_on_fill(
+    token_addr: str,
+    symbol: str,
+    side: str,
+    qty: float,
+    price_usd: float,
+    fee_usd: float,
+    txid: str | None,
+    simulated: bool,
+    **meta
+) -> None:
+    """
+    Best-effort call into a MetricsStore-like object.
+    Prefer new _metrics_store API (record_fill), fall back to METRICS alias.
+    Swallows any errors.
+    """
+    try:
+        global _metrics_store, METRICS
+        ms = _metrics_store or METRICS
+        if not ms:
+            return
+        # Prefer structured record_fill if available
+        if hasattr(ms, "record_fill"):
+            try:
+                ms.record_fill(
+                    token_addr=token_addr,
+                    side=side.upper(),
+                    qty=qty,
+                    price_usd=price_usd,
+                    fee_usd=fee_usd,
+                    dry_run=simulated,
+                    txid=txid,
+                    symbol=symbol,
+                    **meta,
+                )
+                return
+            except Exception:
+                pass
+        # Fallback to generic 'record' method if present
+        if hasattr(ms, "record"):
+            try:
+                ms.record({
+                    "type": "fill",
+                    "token": token_addr,
+                    "symbol": symbol,
+                    "side": side.upper(),
+                    "qty": qty,
+                    "price_usd": price_usd,
+                    "fee_usd": fee_usd,
+                    "txid": txid,
+                    "simulated": simulated,
+                    **meta,
+                })
+            except Exception:
+                pass
+    except Exception:
+        # Never let metrics fail trading logic
+        try:
+            logger.debug("Metrics on_fill failed", exc_info=True)
+        except Exception:
+            pass
+
+
+def _metrics_snapshot_equity_point(logger: logging.Logger | None = None) -> None:
+    """
+    Best-effort call to snapshot equity / point-in-time metrics.
+    No-op if metrics store lacks such API.
+    """
+    try:
+        global _metrics_store, METRICS
+        ms = _metrics_store or METRICS
+        if not ms:
+            return
+        if hasattr(ms, "snapshot_equity_point"):
+            try:
+                ms.snapshot_equity_point()
+                return
+            except Exception:
+                pass
+        # fallback: record a "snapshot" event if generic record exists
+        if hasattr(ms, "record"):
+            try:
+                ms.record({"type": "equity_snapshot", "ts": int(time.time())})
+            except Exception:
+                pass
+    except Exception:
+        if logger:
+            try:
+                logger.debug("Metrics snapshot failed", exc_info=True)
+            except Exception:
+                pass
+
+# Candlestick / BB helpers (best-effort; inert if numpy/pandas absent)
+_patterns_module = None
+_pd = None
+_np = None
+try:
+    import numpy as _np  # type: ignore
+except Exception:
+    _np = None
+try:
+    import pandas as _pd  # type: ignore
+except Exception:
+    _pd = None
+try:
+    # Support a numpy-based patterns module or a local candlestick_patterns module
+    import candlestick_patterns as _patterns_module  # type: ignore
+except Exception:
+    try:
+        # package-style import
+        from solana_trading_bot_bundle.trading_bot import candlestick_patterns as _patterns_module  # type: ignore
+    except Exception:
+        _patterns_module = None
+
+def attach_patterns_if_available(token: dict) -> None:
+    """
+    If token has OHLC arrays or a prebuilt pandas DataFrame, attempt to attach
+    pattern booleans (pat_<name>_xx) in-place. Defensive: returns silently if
+    required libs or data are missing.
+    """
+    try:
+        if not _patterns_module:
+            return
+        # Prefer a pandas DataFrame if present
+        df = None
+        if isinstance(token.get("_ohlc_df"), _pd.DataFrame) if _pd else False:
+            df = token.get("_ohlc_df")
+        else:
+            # try to build a DataFrame from _ohlc_close/_ohlc_open/_ohlc_high/_ohlc_low
+            if _pd and isinstance(token.get("_ohlc_close"), (list, tuple)):
+                try:
+                    close = list(token.get("_ohlc_close") or [])
+                    open_ = list(token.get("_ohlc_open") or [])
+                    high = list(token.get("_ohlc_high") or [])
+                    low = list(token.get("_ohlc_low") or [])
+                    vol = list(token.get("_ohlc_volume") or token.get("_ohlc_vol") or [])
+                    if len(close) and len(close) == len(open_) == len(high) == len(low):
+                        df = _pd.DataFrame({
+                            "open": open_,
+                            "high": high,
+                            "low": low,
+                            "close": close,
+                            "volume": vol if vol else [0] * len(close)
+                        })
+                except Exception:
+                    df = None
+        if df is None:
+            return
+        # call classifier if present
+        try:
+            pat_hits = _patterns_module.classify_patterns(df)  # defensive: may raise
+        except Exception:
+            pat_hits = {}
+        # attach booleans for last row existence if classifier returns series/dicts
+        for name, arr in (pat_hits or {}).items():
+            try:
+                # arr could be list-like (per-bar); set token field to last value boolean
+                if isinstance(arr, (list, tuple)):
+                    token[f"pat_{name}_last"] = bool(arr[-1])
+                else:
+                    token[f"pat_{name}_last"] = bool(arr)
+            except Exception:
+                token[f"pat_{name}_last"] = False
+    except Exception:
+        try:
+            logger.debug("attach_patterns_if_available failed for %s", token.get("symbol", token.get("address")), exc_info=True)
+        except Exception:
+            pass
+
+def _attach_bbands_if_available(token: dict, window: int = 20, stdev: float = 2.0) -> None:
+    """
+    If token contains _ohlc_close (list) or _ohlc_df (pandas), compute Bollinger Bands
+    (basis, upper, lower) and attach boolean signals bb_long, bb_short for last row.
+    Defensive: no-op if pandas/numpy not available.
+    """
+    try:
+        if not _pd or not _np:
+            return
+        df = None
+        if isinstance(token.get("_ohlc_df"), _pd.DataFrame):
+            df = token.get("_ohlc_df")
+        elif isinstance(token.get("_ohlc_close"), (list, tuple)):
+            close = list(token.get("_ohlc_close") or [])
+            if len(close) < window:
+                return
+            df = _pd.DataFrame({"close": close})
+        else:
+            return
+
+        if "close" not in df.columns:
+            return
+        # compute rolling mean and std
+        try:
+            basis = df["close"].rolling(window=window, min_periods=window).mean()
+            dev = df["close"].rolling(window=window, min_periods=window).std()
+            upper = basis + dev * stdev
+            lower = basis - dev * stdev
+            # attach last values if present
+            token["bb_basis"] = float(basis.iloc[-1]) if not _np.isnan(basis.iloc[-1]) else None
+            token["bb_upper"] = float(upper.iloc[-1]) if not _np.isnan(upper.iloc[-1]) else None
+            token["bb_lower"] = float(lower.iloc[-1]) if not _np.isnan(lower.iloc[-1]) else None
+            # simple signals: price cross over / under
+            close_last = float(df["close"].iloc[-1])
+            token["bb_long"] = (token.get("bb_lower") is not None and close_last <= token["bb_lower"])
+            token["bb_short"] = (token.get("bb_upper") is not None and close_last >= token["bb_upper"])
+        except Exception:
+            # safe to ignore any numeric oddities
+            return
+    except Exception:
+        try:
+            logger.debug("attach_bbands_if_available failed for %s", token.get("symbol", token.get("address")), exc_info=True)
+        except Exception:
+            pass
+
*** End Patch